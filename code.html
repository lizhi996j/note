<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>code</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="code_files/libs/clipboard/clipboard.min.js"></script>
<script src="code_files/libs/quarto-html/quarto.js"></script>
<script src="code_files/libs/quarto-html/popper.min.js"></script>
<script src="code_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="code_files/libs/quarto-html/anchor.min.js"></script>
<link href="code_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="code_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="code_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="code_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="code_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="used-code" class="level3">
<h3 class="anchored" data-anchor-id="used-code">Used Code</h3>
<section id="os-module" class="level4">
<h4 class="anchored" data-anchor-id="os-module">os module</h4>
<ol type="1">
<li><code>os.path.dirname</code>: 返回文件路径</li>
<li><code>os.path.abspath</code>: 返回绝对路径</li>
<li><code>os.path.realpath</code>: 去除符号链接(symbolic link)</li>
<li><code>__file__</code>: 返回当前文件路径; （如果在包里，则是包的地址）</li>
</ol>
</section>
<section id="sys-module" class="level4">
<h4 class="anchored" data-anchor-id="sys-module">sys module</h4>
<ol type="1">
<li><code>sys.argv</code>: 命令行参数</li>
<li><code>sys.path</code>: 模块搜索路径</li>
<li><code>sys.exit()</code>: 退出程序</li>
</ol>
</section>
<section id="collections-module" class="level4">
<h4 class="anchored" data-anchor-id="collections-module">collections module</h4>
</section>
<section id="python" class="level4">
<h4 class="anchored" data-anchor-id="python">python</h4>
<ol type="1">
<li><p>标准容器：<code>list</code>, <code>tuple</code>, <code>dict</code>, <code>set</code></p>
<ul>
<li><code>list</code>: 可变，有序，元素可重复</li>
<li><code>tuple</code>: 不可变，有序，元素可重复</li>
<li><code>dict</code>: key-value对，key不可重复</li>
<li><code>set</code>: 不可重复，无序</li>
</ul></li>
<li><p><code>list</code> 方法：</p>
<ul>
<li><code>append(x)</code>: 将元素 x 添加到列表的末尾</li>
<li><code>extend(iterable)</code>: 将可迭代对象的元素添加到列表的末尾</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>lst <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>lst.append([<span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lst)  <span class="co"># 输出: [1, 2, 3, [4, 5]]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>.extend([<span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lst)  <span class="co"># 输出: [1, 2, 3, 4, 5]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>sort(key=None, reverse=False)</code>: 对列表进行排序</li>
<li><code>insert(i, x)</code>: 在索引 i 处插入元素 x</li>
<li><code>remove(x)</code>: 删除列表中第一个值为 x 的元素</li>
<li><code>pop([i])</code>: 删除索引 i 处的元素，并返回它。如果未指定索引，则删除最后一个元素</li>
<li><code>clear()</code>: 删除列表中的所有元素</li>
<li><code>index(x[, start[, end]])</code>: 返回列表中第一个出现的元素 x 的索引位置。如果指定了 start 和 end，则在指定的范围内查找</li>
<li><code>count(x)</code>: 返回列表中值为 x 的元素的数量</li>
</ul></li>
<li><p><code>dict</code> 方法：</p>
<ul>
<li><code>get(key[, default])</code>: 返回键 key 对应的值。如果键不存在，则返回默认值 default</li>
<li><code>pop(key[, default])</code>: 删除键 key 对应的值，并返回它。如果键不存在，则返回默认值 default</li>
<li><code>popitem()</code>: 删除并返回字典中的一个键值对。字典是无序的，所以不保证删除哪个键值对</li>
<li><code>clear()</code>: 删除字典中的所有键值对</li>
<li><code>update([other])</code>: 将字典 other 中的键值对添加到字典中。如果键已存在，则覆盖它</li>
<li><code>keys()</code>: 返回字典中的所有键</li>
<li><code>values()</code>: 返回字典中的所有值</li>
<li><code>items()</code>: 返回字典中的所有键值对</li>
<li>迭代字典的方式：
<ol type="1">
<li>方式1：</li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>my_dict <span class="op">=</span> {<span class="st">'a'</span>: <span class="dv">1</span>, <span class="st">'b'</span>: <span class="dv">2</span>, <span class="st">'c'</span>: <span class="dv">3</span>}</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, value <span class="kw">in</span> my_dict.items():</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(key, value)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>方式2：</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key <span class="kw">in</span> my_dict:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(key, my_dict[key])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li><p>可迭代对象：</p>
<ul>
<li><code>zip()</code>: 将多个可迭代对象（如列表、元组等）中的元素打包成一个元组迭代器，每个元组包含来自每个可迭代对象对应位置的元素</li>
<li><code>enumerate()</code>: 返回元素和索引</li>
<li><code>reversed()</code>: 返回反向迭代器</li>
<li><code>sorted(iterable, key=None, reverse=False)</code>: 排序函数
<ul>
<li><code>iterable</code>: 需要排序的可迭代对象（如列表、元组、字符串等）</li>
<li><code>key</code>: 一个函数，用于从每个元素中提取用于排序的关键字。如果未指定，则直接比较元素</li>
<li><code>reverse</code>: 一个布尔值。如果为 True，则按降序排序；如果为 False（默认值），则按升序排序</li>
</ul></li>
</ul></li>
<li><p><code>list()</code>, <code>dict()</code></p></li>
<li><p><code>",".join()</code>: 连成字符串</p></li>
<li><p>函数变量</p></li>
<li><p>字典解析： <code>python     my_dict = {'a': 1, 'b': 2, 'c': 3}     def my_function(a, b, c):         print(a, b, c)     my_function(**my_dict)</code> ```python def test4(a, b=2, *args, **kwargs): print(a, b, args, kwargs) test4(1) test4(1, 1) test4(1, <em>(1, 2, 3, 3, 4,)) test4(1, </em>(1, 2, 3, 3, 4,), cc=123, c=123)</p>
<p>lists = [“a”, “b”] dicts = {“key”: 123} test4(1, *lists, **dicts) ```</p></li>
<li><p>创建字典： <code>python     dic_values = {'%g' % (line[0]): line[1:] for line in values}</code></p></li>
<li><p><code>pass</code>: 啥也不干</p></li>
<li><p>写入 CSV： <code>python     with open('file.csv', 'w') as f:         writer = csv.writer(f)         writer.writerows(data)</code></p></li>
<li><p>集合操作：</p>
<ul>
<li>交：<code>set1 &amp; set2</code></li>
<li>并：<code>set1 | set2</code></li>
<li>差：<code>set1 - set2</code></li>
<li>对称差：<code>set1 ^ set2</code></li>
</ul></li>
<li><p><code>yield</code> 是 Python 中的一个关键字，用于定义生成器函数。生成器使用 <code>yield</code> 而不是 <code>return</code> 来返回值。每次调用生成器的 <code>__next__()</code> 方法时，函数执行到 <code>yield</code> 语句，返回一个值并暂停执行，直到下一次调用 <code>__next__()</code> 才继续从暂停的位置执行。这使得生成器可以一次返回一个值，而不是一次返回所有值，节省内存。</p>
<p><strong>示例</strong>：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_generator():</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="dv">1</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="dv">2</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="dv">3</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用生成器</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>gen <span class="op">=</span> simple_generator()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">next</span>(gen))  <span class="co"># 输出: 1</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">next</span>(gen))  <span class="co"># 输出: 2</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">next</span>(gen))  <span class="co"># 输出: 3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>filter函数：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">filter</span>(function, iterable)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    ```</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> function: 过滤函数，返回True<span class="op">/</span><span class="va">False</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> iterable: 可迭代对象（如列表、元组等）</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> 返回一个filter对象，通常需要转换为list</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> 示例：</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>```python</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>输出：</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>, <span class="dv">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>map函数： <code>map()</code> 函数是 Python 的一个内置函数，用于将一个函数应用到可迭代对象（如列表、元组等）的每个元素上。它返回一个 map 对象（迭代器）。</p>
<p>基本语法：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">map</span>(function, iterable, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>以下是一些常见用法示例：</p>
<ol type="1">
<li><strong>基本使用</strong>：</li>
</ol>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 将列表中的每个数字平方</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>squared <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x<span class="op">**</span><span class="dv">2</span>, numbers)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(squared))  <span class="co"># 输出: [1, 4, 9, 16, 25]</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 将字符串转换为整数</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>str_nums <span class="op">=</span> [<span class="st">'1'</span>, <span class="st">'2'</span>, <span class="st">'3'</span>, <span class="st">'4'</span>]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>int_nums <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, str_nums)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(int_nums))  <span class="co"># 输出: [1, 2, 3, 4]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><strong>使用自定义函数</strong>：</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multiply_by_two(x):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>doubled <span class="op">=</span> <span class="bu">map</span>(multiply_by_two, numbers)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(doubled))  <span class="co"># 输出: [2, 4, 6, 8]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li><strong>处理多个迭代器</strong>：</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 将两个列表对应元素相加</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>list1 <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>list2 <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>summed <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y, list1, list2)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(summed))  <span class="co"># 输出: [11, 22, 33]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="4" type="1">
<li><strong>结合字符串操作</strong>：</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 将所有字符串转为大写</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>words <span class="op">=</span> [<span class="st">'hello'</span>, <span class="st">'world'</span>, <span class="st">'python'</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>upper_words <span class="op">=</span> <span class="bu">map</span>(<span class="bu">str</span>.upper, words)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(upper_words))  <span class="co"># 输出: ['HELLO', 'WORLD', 'PYTHON']</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>重要特点：</p>
<ol type="1">
<li>map() 返回一个迭代器，需要使用 list() 或其他方式转换才能查看结果</li>
<li>比列表推导式更适合处理简单的转换</li>
<li>可以处理多个输入迭代器</li>
<li>内存效率高，因为它是惰性计算的</li>
</ol>
<p>对比列表推导式：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用 map</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>squared_map <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> x: x<span class="op">**</span><span class="dv">2</span>, numbers)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用列表推导式</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>squared_list <span class="op">=</span> [x<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> x <span class="kw">in</span> numbers]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 两者结果相同，但使用场景可能不同</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>使用建议：</p>
<ol type="1">
<li>当需要对序列中的每个元素应用相同的函数时，使用 map()</li>
<li>当转换逻辑简单时，map() 可能比列表推导式更清晰</li>
<li>当处理大量数据时，map() 的惰性计算特性可能更有优势</li>
<li>如果需要更复杂的转换逻辑，可能列表推导式更合适</li>
</ol></li>
</ol>
</section>
<section id="numpy-module" class="level4">
<h4 class="anchored" data-anchor-id="numpy-module">numpy module</h4>
<section id="np.array" class="level5">
<h5 class="anchored" data-anchor-id="np.array">np.array</h5>
<ul>
<li>reshape：</li>
</ul>
<p>.reshape 方法用于改变数组的形状，而不改变其数据。它返回一个新的数组，具有指定的形状。</p>
<p><strong>示例</strong>：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建一个一维数组</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 将一维数组重塑为二维数组</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a.reshape((<span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(b)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 输出：</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co"># [[1 2 3]</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">#  [4 5 6]]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>在上述示例中，<code>reshape</code> 方法将一维数组 <code>a</code> 重塑为一个 2 行 3 列的二维数组 <code>b</code>。</p>
<p>reshape参数</p>
</section>
<section id="numpy.linalg-包" class="level5">
<h5 class="anchored" data-anchor-id="numpy.linalg-包">numpy.linalg 包</h5>
<ul>
<li><code>np.linalg.inv(a)</code>: 计算矩阵的逆</li>
<li><code>np.linalg.eig(a)</code>: 计算矩阵的特征值和特征向量</li>
<li><code>np.linalg.det(a)</code>: 计算矩阵的行列式</li>
<li><code>np.linalg.solve(a, b)</code>: 求解线性矩阵方程</li>
<li><code>np.linalg.cholesky(a)</code>: Cholesky 分解 ##### 运算：</li>
<li><code>np.dot(v1, v2)</code>: 向量点乘</li>
<li><code>np.linalg.norm(v)</code>: 向量范数</li>
<li><code>np.sum(a, axis=0)</code>: 按行求和 ##### numpy函数</li>
</ul>
<ol type="1">
<li>sum函数
<ul>
<li>axis参数是从最外层开始算的，最外层是0层</li>
<li>keepdims保留维度的位置。保留位置是说留一位，比如1*1的矩阵</li>
<li>where参数可以是条件表达式或与原数组形状兼容的布尔数组，否则报错；</li>
</ul></li>
<li>where函数</li>
<li>高维numpy数组乘法*：
<ul>
<li><p><strong>基本规则：</strong></p>
<ul>
<li>假设有两个数组 <code>A</code> 和 <code>B</code>。</li>
<li>如果这两个数组的维度相同，且每个维度的长度相同，那么它们可以进行元素级的乘法。</li>
<li>如果这两个数组的维度不同，或者维度相同但长度不同，那么它们无法进行元素级的乘法。</li>
</ul></li>
<li><p><strong>广播机制：</strong></p>
<ul>
<li>如果两个数组的维度数不同，将维度较小的数组的形状前面补1，使得两个数组具有相同的维度数。</li>
<li>然后，从后向前比较两个数组的每一个维度：
<ul>
<li>如果两个维度的长度相同，或者其中一个维度的长度是1，那么这两个维度是兼容的，可以进行广播。</li>
<li>如果两个维度的长度不相同且都不为1，则无法进行广播，抛出错误。</li>
</ul></li>
<li>广播之后，每个数组的形状将是两个数组形状的各个维度的最大值。</li>
<li>在计算过程中，长度为1的维度将沿着该维度重复，以匹配最大长度。</li>
</ul></li>
<li><p><strong>示例</strong>： ```python import numpy as np</p>
<p># 创建两个数组 A = np.array([[1, 2], [3, 4], [5, 6]]) B = np.array([[2, 3], [4, 5], [6, 7]])</p>
<p># 对两个数组进行元素级乘法 C = A * B</p>
<p>print(C) # 输出： # [[ 2 6] # [12 20] # [30 42]] ```</p></li>
</ul></li>
</ol>
</section>
<section id="广播机制" class="level5">
<h5 class="anchored" data-anchor-id="广播机制">广播机制：</h5>
<ol type="1">
<li>如果数组的维度数不同，将维度较小的数组的形状前面补1，使得两个数组具有相同的维度数。</li>
<li>然后，从后向前比较两个数组的每一个维度：
<ul>
<li>如果两个维度的长度相同，或者其中一个维度的长度是1，那么这两个维度是兼容的，可以进行广播。</li>
<li>如果两个维度的长度不相同且都不为1，则无法进行广播，抛出错误。</li>
</ul></li>
<li>广播之后，每个数组的形状将是两个数组形状的各个维度的最大值。</li>
<li>在计算过程中，长度为1的维度将沿着该维度重复，以匹配最大长度。</li>
</ol>
</section>
<section id="其它" class="level5">
<h5 class="anchored" data-anchor-id="其它">其它：</h5>
<ol type="1">
<li><code>np.random.permutation</code></li>
<li><code>.squeeze</code>: 删除为1的维度</li>
<li><code>np.where</code>: 条件筛选，条件赋值</li>
<li><code>np.logical_and</code>: 按元素求交</li>
</ol>
</section>
</section>
<section id="pandas" class="level4">
<h4 class="anchored" data-anchor-id="pandas">Pandas</h4>
<p>Pandas主要有两种数据结构：DataFrame和Series。 Pandas转换为numpy： <code>DataFrame.values</code> Pandas与Numpy的主要区别： - Pandas的索引可以有标签。 - Pandas各列数据是异质的。Numpy数据类型是同质的。 1. <code>pd.read_csv</code> 2. <code>pd.DataFrame</code>： 1. 一般用法： DataFrame 构造方法如下： <code>python    pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False)</code></p>
<p>参数说明： - <code>data</code>：DataFrame 的数据部分 - 可以是字典、二维数组、Series、DataFrame 或其他可转换为 DataFrame 的对象 - 如果不提供此参数，则创建一个空的 DataFrame - <code>index</code>：DataFrame 的行索引 - 用于标识每行数据 - 可以是列表、数组、索引对象等 - 如果不提供此参数，则创建一个默认的整数索引 - <code>columns</code>：DataFrame 的列索引<br>
- 用于标识每列数据 - 可以是列表、数组、索引对象等 - 如果不提供此参数，则创建一个默认的整数索引 - <code>dtype</code>：指定 DataFrame 的数据类型 - 可以是 NumPy 的数据类型，例如 np.int64、np.float64 等 - 如果不提供此参数，则根据数据自动推断数据类型 - <code>copy</code>：是否复制数据 - 默认为 False，表示不复制数据 - 如果设置为 True，则复制输入的数据 2. 数据框的创建： 1. <strong>从列表创建数据框：</strong> ```python import pandas as pd</p>
<pre><code>    data = [['Google', 10], ['Runoob', 12], ['Wiki', 13]]

   # 创建DataFrame
   df = pd.DataFrame(data, columns=['Site', 'Age'])

   # 使用astype方法设置每列的数据类型
   df['Site'] = df['Site'].astype(str)
   df['Age'] = df['Age'].astype(float)

   print(df)
   ```

  1. **两种从字典创建数据框的方法**：
   法一：
   ```python
   import pandas as pd

   data = {'Site': ['Google', 'Runoob', 'Wiki'], 'Age': [10, 12, 13]}
   df = pd.DataFrame(data)
   print(df)
   ```  
   法二：
   ```python
   import pandas as pd

   data = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]

   df = pd.DataFrame(data)

   print (df)
   ```
   2. **从numpy数组创建数据框：**
   ```python
   import pandas as pd
   import numpy as np

   data = np.array([[1, 2, 3], [4, 5, 6]])
   df = pd.DataFrame(data, columns=['A', 'B', 'C'])
   print(df)
   ```
3. **使用行/列的位置/标签索引**： `loc`/`iloc`方法： (i的意思是index)
    1. 使用行标签返回一行或多行数据：
    ```python
    import pandas as pd
    import pandas as pd

    data = {
    "calories": [420, 380, 390],
    "duration": [50, 40, 45]
    }

    df = pd.DataFrame(data, index = ["day1", "day2", "day3"])

    # 指定索引
    print(df.loc[["day2", "day2"]])
    # 如果使用如下会报错，因为此时行标签不是0，1，2了，此时要使用iloc
    print(df.loc[[0, 1]]) 
    # 不能直接使用索引/标签获得元素
    print(df.loc["day1", "calories"])
    # 需要先使用列索引再用行索引
    print(df["calories"]["day1"])
    #可以使用如下代码切片行：（区间左闭右开）
    print(df[1:3])
    ```
    **注意上面例子中iloc和loc的区别**
    2. 使用行索引返回一行或多行数据：
    ```python
    import pandas as pd

    data = {
    "calories": [420, 380, 390],
    "duration": [50, 40, 45]
    }

    # 数据载入到 DataFrame 对象
    df = pd.DataFrame(data)

    # 返回第一行和第二行
    print(df.loc[[0, 1]])
    ```
4. 数据的增删改查：
```python
#修改列数据：
df['calories'] = [100, 200, 300]
#增加一列或多列数据：
df['new_column'] = [100, 200, 300]
  
  #使用字典增加多列：(注意：新DataFrame的索引与原DataFrame不匹配会导致NaN，因此需要index.)
new_cols = {
'col1': [1, 2, 3],
'col2': [4, 5, 6]
}
df = df.join(pd.DataFrame(new_cols, index=["day1", "day2", "day3"]))

  #使用assign方法增加多列：
df = df.assign(col3=[7, 8, 9], col4=[10, 11, 12])

# 增加一行或多行数据：使用 loc、concat 方法 
df.loc['day4'] = [100, 200]

new_row = pd.DataFrame({'calories': [100], 'duration': [50]}, index=['day5'])
df = pd.concat([df, new_row], ignore_index=True)#ignore_index=True 表示忽略原来的索引，重新生成索引 

# 删除行数据：
# 删除单行
df = df.drop(index='row_label')  # 使用行标签
# 或
df = df.drop(0)  # 使用行索引号
# 删除多行
df = df.drop(index=['row1', 'row2'])  # 使用行标签列表
# 或
df = df.drop([0, 1])  # 使用行索引号列表

# 删除列数据
# 删除单列
df = df.drop('column_name', axis=1)  # 使用列名
# 或
df = df.drop(columns='column_name')  # 使用 columns 参数
# 删除多列
df = df.drop(['col1', 'col2'], axis=1)  # 使用列名列表
# 或
df = df.drop(columns=['col1', 'col2'])
```
5. dataFrame的属性和方法：
**基础属性和查看数据:**
- shape: 返回 DataFrame 的行数和列数（行数, 列数）
- columns: 返回 DataFrame 的所有列名
- index: 返回 DataFrame 的行索引
- dtypes: 返回每一列的数值数据类型
- head(n): 返回 DataFrame 的前 n 行数据（默认前 5 行）
- tail(n): 返回 DataFrame 的后 n 行数据（默认后 5 行）
- info(): 显示 DataFrame 的简要信息，包括列名、数据类型、非空值数量等
- describe(): 返回 DataFrame 数值列的统计信息，如均值、标准差、最小值等
**索引、选择和排序:**
- loc[]: 按标签索引选择数据
- iloc[]: 按位置索引选择数据
- at[]: 访问 DataFrame 中单个元素（比 loc[] 更高效）
- iat[]: 访问 DataFrame 中单个元素（比 iloc[] 更高效）
- sort_values(by): 按照指定列排序
- sort_index(): 按行索引排序
**数据清洗和转换:**
- dropna(): 删除含有缺失值（NaN）的行或列
- fillna(value): 用指定的值填充缺失值
- isnull(): 判断缺失值，返回一个布尔值 DataFrame
- notnull(): 判断非缺失值，返回一个布尔值 DataFrame
- apply(func): 对 DataFrame 或 Series 应用一个函数
- applymap(func): 对 DataFrame 的每个元素应用函数（仅对 DataFrame）
- groupby(by): 分组操作，用于按某一列分组进行汇总统计
- pivot_table(): 创建透视表
**合并、连接和导出:**
- merge(): 合并多个 DataFrame（类似 SQL 的 JOIN 操作）
- concat(): 按行或按列连接多个 DataFrame
- to_csv(): 将 DataFrame 导出为 CSV 文件
- to_excel(): 将 DataFrame 导出为 Excel 文件
- to_json(): 将 DataFrame 导出为 JSON 格式
- to_sql(): 将 DataFrame 导出为 SQL 数据库
**其他数据操作:**
- query(): 使用 SQL 风格的语法查询 DataFrame
- duplicated(): 返回布尔值 DataFrame，指示每行是否是重复的
- drop_duplicates(): 删除重复的行
- set_index(): 设置 DataFrame 的索引
- reset_index(): 重置 DataFrame 的索引
- transpose(): 转置 DataFrame（行列交换）
6. 从csv中读取和写入文件：
读取：DataFrame.read_csv():

| 参数 | 说明 | 默认值 |
|------|------|--------|
| filepath_or_buffer | CSV 文件的路径或文件对象（支持 URL、文件路径、文件对象等）| 必需参数 |
| sep | 定义字段分隔符，默认是逗号（,），可以改为其他字符，如制表符（\t）| ',' |
| header | 指定行号作为列标题，默认为 0（表示第一行），或者设置为 None 没有标题 | 0 |
| names | 自定义列名，传入列名列表 | None |
| index_col | 用作行索引的列的列号或列名 | None |
| usecols | 读取指定的列，可以是列的名称或列的索引 | None |
| dtype | 强制将列转换为指定的数据类型 | None |
| skiprows | 跳过文件开头的指定行数，或者传入一个行号的列表 | None |
| nrows | 读取前 N 行数据 | None |
| na_values | 指定哪些值应视为缺失值（NaN）| None |
| skipfooter | 跳过文件结尾的指定行数 | 0 |
| encoding | 文件的编码格式（如 utf-8，latin1 等）| None |

写入：DataFrame.to_csv(): 注意这里是 DataFrame. 不是pd.
| 参数 | 说明 | 默认值 |
|------|------|--------|
| path_or_buffer | CSV 文件的路径或文件对象（支持文件路径、文件对象）| 必需参数 |
| sep | 定义字段分隔符，默认是逗号（,），可以改为其他字符，如制表符（\t）| ',' |
| index | 是否写入行索引，默认 True 表示写入索引 | True |
| columns | 指定写入的列，可以是列的名称列表 | None |
| header | 是否写入列名，默认 True 表示写入列名，设置为 False 表示不写列名 | True |
| mode | 写入文件的模式，默认是 w（写模式），可以设置为 a（追加模式）| 'w' |
| encoding | 文件的编码格式，如 utf-8，latin1 等 | None |

7. 指定每列的数据类型：(也可以在读取csv时指定)
```python
import pandas as pd

# 创建一个 DataFrame
df = pd.DataFrame({
    'A': [1, 2, 3],
    'B': ['4', '5', '6'],
    'C': [7.1, 8.2, 9.3]
})

# 为每一列指定不同的数据类型
df = df.astype({
    'A': 'float64',  # 将列 A 转换为浮点数
    'B': 'int32',    # 将列 B 转换为整数
    'C': 'int64'     # 将列 C 转换为整数
})

print(df)
print(df.dtypes)
```</code></pre>
<ol start="3" type="1">
<li><p>Pandas 数据清洗：</p>
<ol type="1">
<li>删除空值 DataFrame.dropna(axis=0, how=‘any’, thresh=None, subset=None, inplace=False)</li>
</ol>
<p>参数说明： | 参数 | 说明 | 默认值 | |——|——|——–| | axis | 删除的方向。0表示删除含空值的行，1表示删除含空值的列 | 0 | | how | 删除的条件。‘any’表示任意值为空就删除，’all’表示所有值为空才删除 | ’any’ | | thresh | 保留至少含有n个非空值的行/列 | None | | subset | 指定在哪些列中检查是否存在空值，可传入列名列表 | None | | inplace | 是否原地修改。True表示直接修改原数据并返回None | False |</p>
<p>Pandas 把 n/a 和 NA 当作空数据，na 不是空数据，不符合我们要求，我们可以指定空数据类型： ```python import pandas as pd</p>
<p>missing_values = [“n/a”, “na”, “–”] df = pd.read_csv(‘property-data.csv’, na_values = missing_values)</p>
<p>print (df[‘NUM_BEDROOMS’]) print (df[‘NUM_BEDROOMS’].isnull()) print (df.isnull().any(axis=0))#返回各列是否有空值 ```</p>
<ol start="2" type="1">
<li>填充空值</li>
<li>数据格式错误处理</li>
<li>清洗错误数据</li>
<li>清洗重复数据</li>
</ol></li>
<li><p>pandas 聚合与排序 4.1. <strong>排序：</strong> 4.1.1.DataFrame.sort_values(by,axis=0,ascending=True,inplace=False) <code>df.sort_values(by=[0], axis=0)</code> 是 pandas 中用于对 DataFrame 排序的方法。让我们逐步分析这个方法的作用。</p>
<p><strong>基本语法</strong> <code>python  DataFrame.sort_values(by, axis=0, ascending=True, inplace=False)</code></p>
<ul>
<li><code>by</code>：排序依据的列名或列索引（当 <code>axis=0</code> 时），或行索引/行标签（当 <code>axis=1</code> 时）。</li>
<li><code>axis</code>：
<ul>
<li><code>axis=0</code>：对行排序，默认行为。通常基于列的值排序。</li>
<li><code>axis=1</code>：对列排序，通常基于索引或行的值排序。</li>
</ul></li>
<li><code>ascending</code>：是否升序排列，默认为 True。</li>
<li><code>inplace</code>：是否直接修改原 DataFrame，默认为 False。</li>
</ul>
<p><strong>示例</strong></p>
<p><strong>示例 1：按某一列的值排序</strong> 假设有一个 DataFrame： ```python import pandas as pd</p>
<p>data = {0: [3, 1, 2], ‘B’: [‘x’, ‘y’, ‘z’]} df = pd.DataFrame(data)</p>
<p>print(df) <code>输出：</code>css 0 B 0 3 x 1 1 y 2 2 z <code>对第 0 列（列名为 0）排序：</code>python sorted_df = df.sort_values(by=[0], axis=0) print(sorted_df) <code>输出：</code>css 0 B 1 1 y 2 2 z 0 3 x ```</p>
<ul>
<li><code>axis=0</code> 指示按行排序（基于列的值）。</li>
<li><code>by=[0]</code> 指定排序的依据是第 0 列。</li>
</ul>
<p><strong>示例 2：按多个列排序</strong> 如果你有多个排序依据，可以传递一个列表。例如： ```python data = {‘A’: [3, 1, 2], ‘B’: [2, 2, 1]} df = pd.DataFrame(data)</p>
<p>sorted_df = df.sort_values(by=[‘B’, ‘A’], axis=0) print(sorted_df) <code>输出：</code>css A B 2 2 1 1 1 2 0 3 2 ``` 这里先按列 B 排序，如果值相同，则按列 A 排序。 <strong>注意事项</strong></p>
<ul>
<li>列的名称类型：<code>by</code> 中指定的列名需要与 DataFrame 的列名一致。如果列名是整数（如 <code>[0]</code>），则需要传入整数，而非字符串。</li>
<li>原地修改：<code>inplace=True</code> 会直接修改原 DataFrame，不会返回新对象。</li>
<li>排序稳定性：当多行有相同值时，<code>sort_values</code> 会保持原来的顺序。</li>
</ul>
<p>4.1.2. DataFrame.sort_index(axis=0,ascending=True,inplace=False) 若需要按索引排序，可以使用 <code>sort_index()</code> 方法，而不是 <code>sort_values()</code>。 <code>python  df_sorted = df.sort_index(axis=0, ascending=False)  print(df_sorted)</code> 4.2. 分组后聚合 | 操作 | 方法 | 说明 | 示例 | | — | — | — | — | | 按列分组并聚合 | df.groupby(by).agg() | 按指定列（by）进行分组，agg() 可以传入不同的聚合函数，进行多种操作 | df.groupby(‘Department’).agg({‘Salary’: ‘mean’}) | | 多重聚合函数应用 | df.groupby(by).agg([func1, func2]) | 可以对同一列应用多个聚合函数，返回多种聚合结果 | df.groupby(‘Department’).agg({‘Salary’: [‘mean’, ‘sum’]}) | 例子： <code>python  #分组聚合  import pandas as pd  data={      'Department': ['HR', 'Finance', 'HR', 'IT', 'IT'],      'Employee': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],      'Salary': [50000, 60000, 55000, 70000, 75000]  }  df=pd.DataFrame(data)  df.groupby("Department").agg({"Salary":"mean"})  # 多重聚合  df.groupby("Department").agg({"Salary":["mean","sum"]})</code> 4.3 分组后排序 <code>python  df.groupby("Department").apply(lambda x: x.sort_values("Salary"))</code> 注意apply中的匿名函数是对每个分组进行操作，返回的是一个DataFrame</p>
<p><strong>基本语法</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'column_name'</span>).<span class="bu">apply</span>(function)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>'column_name'</code>：用于分组的列。</li>
<li><code>function</code>：应用于每个分组的函数。这可以是一个内置函数，也可以是自定义函数。</li>
</ul>
<p><strong>工作原理</strong></p>
<ol type="1">
<li><strong>分组（groupby）</strong>：按指定列对数据进行分组。</li>
<li><strong>应用（apply）</strong>：对每个分组调用指定函数，函数的输入是分组的一个子 DataFrame，输出可以是标量、Series 或 DataFrame。</li>
</ol>
<p><strong>示例用法</strong></p>
<p><strong>示例 1：对分组数据求和</strong></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">'Category'</span>: [<span class="st">'A'</span>, <span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'B'</span>],</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Values'</span>: [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>]}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 按 'Category' 分组，并计算每组数据的总和</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> df.groupby(<span class="st">'Category'</span>).<span class="bu">apply</span>(<span class="kw">lambda</span> x: x[<span class="st">'Values'</span>].<span class="bu">sum</span>())</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>输出：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode css code-with-copy"><code class="sourceCode css"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Category</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>A    30</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>B    70</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>dtype<span class="in">:</span> int64</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>示例 2：对分组数据进行归一化</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 对每组数据的 'Values' 列进行归一化</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> df.groupby(<span class="st">'Category'</span>).<span class="bu">apply</span>(<span class="kw">lambda</span> x: x.assign(Normalized<span class="op">=</span>x[<span class="st">'Values'</span>] <span class="op">/</span> x[<span class="st">'Values'</span>].<span class="bu">sum</span>()))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>输出：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode css code-with-copy"><code class="sourceCode css"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>Category  Values  Normalized</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>0        A      10    0<span class="fu">.333333</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>1        A      20    0<span class="fu">.666667</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>2        B      30    0<span class="fu">.428571</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>3        B      40    0<span class="fu">.571429</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>示例 3：自定义逻辑应用</strong></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 自定义逻辑，比如对每组数据的值取平均并标记组名</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> custom_function(group):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    mean_value <span class="op">=</span> group[<span class="st">'Values'</span>].mean()</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    group[<span class="st">'Mean'</span>] <span class="op">=</span> mean_value</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> group</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> df.groupby(<span class="st">'Category'</span>).<span class="bu">apply</span>(custom_function)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>输出：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode css code-with-copy"><code class="sourceCode css"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>Category  Values  Mean</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>0        A      10  15<span class="fu">.0</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>1        A      20  15<span class="fu">.0</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>2        B      30  35<span class="fu">.0</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>3        B      40  35<span class="fu">.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>性能</strong>：apply 函数的灵活性较高，但性能可能不如一些特定的聚合函数（如 sum、mean 等）。</li>
<li><strong>函数输入</strong>：自定义函数的输入是每个分组的一个子 DataFrame，可以访问分组内的所有列。</li>
<li><strong>返回值</strong>：返回值可以是 DataFrame、Series 或标量，pandas 会根据返回值调整最终的输出格式。</li>
</ul></li>
<li><p>数据合并与连接</p>
<ol type="1">
<li>数据库风格的连接 — pd.merge() merge() 方法允许根据某些列对两个 DataFrame 进行合并，类似 SQL 中的 JOIN 操作。支持内连接、外连接、左连接和右连接。</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>left</td>
<td>左侧 DataFrame</td>
</tr>
<tr class="even">
<td>right</td>
<td>右侧 DataFrame</td>
</tr>
<tr class="odd">
<td>how</td>
<td>合并方式，支持 ‘inner’, ‘outer’, ‘left’, ‘right’</td>
</tr>
<tr class="even">
<td>on</td>
<td>连接的列名（如果两侧列名不同，可使用 left_on 和 right_on）</td>
</tr>
<tr class="odd">
<td>left_on</td>
<td>左侧 DataFrame 的连接列</td>
</tr>
<tr class="even">
<td>right_on</td>
<td>右侧 DataFrame 的连接列</td>
</tr>
<tr class="odd">
<td>suffixes</td>
<td>添加后缀，以区分重复的列名</td>
</tr>
</tbody>
</table>
<p>示例代码： ```python import pandas as pd</p>
<p># 示例数据 left = pd.DataFrame({‘ID’: [1, 2, 3], ‘Name’: [‘Alice’, ‘Bob’, ‘Charlie’]}) right = pd.DataFrame({‘ID’: [1, 2, 4], ‘Age’: [24, 27, 22]})</p>
<p># 使用 merge 进行内连接 result = pd.merge(left, right, on=‘ID’, how=‘inner’) print(result) ```</p>
<ol start="2" type="1">
<li>沿轴连接 — pd.concat([DataFrame1,DataFrame2],axis=0)</li>
<li>基于索引的连接 — DataFrame.join(DataFrame,how=‘inner’) join() 方法是 Pandas 中的简化连接操作，通常用于基于索引将多个 DataFrame 连接。 merge()方法是基于某列的</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>other</td>
<td>需要连接的另一个 DataFrame</td>
</tr>
<tr class="even">
<td>how</td>
<td>合并方式，支持 ‘left’, ‘right’, ‘outer’, ‘inner’</td>
</tr>
<tr class="odd">
<td>on</td>
<td>使用的连接列，默认基于索引</td>
</tr>
</tbody>
</table>
<p>示例代码： ```python import pandas as pd</p>
<p># 示例数据 left = pd.DataFrame({‘A’: [1, 2, 3]}, index=[1, 2, 3]) right = pd.DataFrame({‘B’: [4, 5, 6]}, index=[1, 2, 4])</p>
<p># 使用 join 进行连接 result = left.join(right, how=‘inner’) print(result) ```</p></li>
<li><p>自定义函数的应用：</p>
<ol type="1">
<li>DataFrame.apply(function，axis=0):应用于行或列</li>
</ol>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(np.random.randint(<span class="dv">0</span>, <span class="dv">10</span>, (<span class="dv">4</span>, <span class="dv">3</span>)), </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>                columns<span class="op">=</span><span class="bu">list</span>(<span class="st">'abc'</span>), </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>                index<span class="op">=</span><span class="bu">range</span>(<span class="dv">4</span>))</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: x.<span class="bu">max</span>()<span class="op">-</span>x.<span class="bu">min</span>(), axis<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>DataFrame.applymap(function):应用于DataFrame的每个元素</li>
</ol>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>df.applymap(<span class="kw">lambda</span> x: x<span class="op">*</span><span class="dv">10</span> <span class="cf">if</span> x<span class="op">%</span><span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> x) <span class="co">#偶数放大10倍</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li>Series.map(function):应用于Series的每个元素,可以是映射字典</li>
</ol>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 示例数据</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'A'</span>: [<span class="st">'cat'</span>, <span class="st">'dog'</span>, <span class="st">'rabbit'</span>]})</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用字典进行映射</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'A'</span>] <span class="op">=</span> df[<span class="st">'A'</span>].<span class="bu">map</span>({<span class="st">'cat'</span>: <span class="st">'kitten'</span>, <span class="st">'dog'</span>: <span class="st">'puppy'</span>})</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ol>
<section id="总结" class="level5">
<h5 class="anchored" data-anchor-id="总结">总结</h5>
<ol type="1">
<li>创建DataFrame:</li>
<li>读取/写入csv</li>
<li>空值处理，重复行处理 空值处理：</li>
</ol>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>DataFrame.isnull().<span class="bu">any</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>DataFrame.dropna(axis<span class="op">=</span><span class="dv">0</span>, how<span class="op">=</span><span class="st">'any'</span>, thresh<span class="op">=</span><span class="va">None</span>, subset<span class="op">=</span><span class="va">None</span>, inplace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>DataFrame.fillna(value<span class="op">=</span><span class="va">None</span>, method<span class="op">=</span><span class="va">None</span>, axis<span class="op">=</span><span class="va">None</span>, inplace<span class="op">=</span><span class="va">False</span>, limit<span class="op">=</span><span class="va">None</span>, downcast<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>重复值处理：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>DataFrame.duplicated(subset<span class="op">=</span><span class="va">None</span>, keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>DataFrame.drop_duplicates(subset<span class="op">=</span><span class="va">None</span>, keep<span class="op">=</span><span class="st">'first'</span>, inplace<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>排序，分组，聚合</li>
<li>数据合并与连接</li>
</ol>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>pd.merge([DataFrame1,DataFrame2],on<span class="op">=</span><span class="va">None</span>,how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>pd.concat([DataFrame1,DataFrame2],axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>DataFrame.join(DataFrame,how<span class="op">=</span><span class="st">'inner'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="matplotlib" class="level4">
<h4 class="anchored" data-anchor-id="matplotlib">matplotlib</h4>
<ol type="1">
<li>plt.show(block=True):</li>
</ol>
</section>
<section id="torch" class="level4">
<h4 class="anchored" data-anchor-id="torch">torch</h4>
<section id="张量操作" class="level5">
<h5 class="anchored" data-anchor-id="张量操作">张量操作：</h5>
<ol type="1">
<li><p>torch.matmul</p>
<ul>
<li><p><strong><code>torch.matmul</code> 的高维行为</strong></p></li>
<li><p><strong>基本规则：</strong></p>
<ul>
<li>假设有两个张量 <code>A</code> 和 <code>B</code>。</li>
<li>如果这两个张量都是一维的（向量），执行<strong>点积</strong>操作，返回一个标量。</li>
<li>如果这两个张量至少有一维是二维或更高维度的张量，<code>torch.matmul</code> 将执行<strong>矩阵乘法</strong>。</li>
<li><strong>高维情况下（维度 ≥ 3）</strong>，<code>torch.matmul</code> 将前面的维度视为批量维度（batch dimensions），并在最后两个维度上执行矩阵乘法。</li>
</ul></li>
<li><p><strong>广播机制</strong></p></li>
</ul>
<p>当张量的维度不同时，PyTorch 会按照以下规则进行广播：</p>
<ol type="1">
<li><strong>对齐维度数：</strong>
<ul>
<li>如果张量的维度数不同，将维度较小的张量的形状前面补 <code>1</code>，使得两个张量具有相同的维度数。</li>
</ul></li>
<li><strong>批量维度的广播：</strong>
<ul>
<li>从后向前比较（不包括最后两个矩阵乘积的维度），如果维度值相同，或者其中一个为 <code>1</code>，则认为是可广播的。</li>
<li>如果两个张量在某个批量维度上不相等且不为 <code>1</code>，则无法广播，操作会报错。</li>
</ul></li>
<li><strong>矩阵乘法：</strong>
<ul>
<li>在匹配并广播批量维度后，<code>torch.matmul</code> 会在最后两个维度上执行矩阵乘法。</li>
</ul></li>
</ol>
<ul>
<li><p><strong>示例</strong></p></li>
<li><p><strong>示例 1：基本批量矩阵乘法</strong></p></li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 A，形状为 [batch_size, M, K]</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> torch.randn(<span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">4</span>)  <span class="co"># 10 个 3x4 的矩阵</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 B，形状为 [batch_size, K, N]</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> torch.randn(<span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">5</span>)  <span class="co"># 10 个 4x5 的矩阵</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 执行批量矩阵乘法</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> torch.matmul(A, B)  <span class="co"># 结果形状为 [10, 3, 5]</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C.shape)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 输出：torch.Size([10, 3, 5])</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong>示例 2：广播批量维度</strong></li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 A，形状为 [batch_size_A, M, K]</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> torch.randn(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)  <span class="co"># 2 个 3x4 的矩阵</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 B，形状为 [K, N]</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> torch.randn(<span class="dv">4</span>, <span class="dv">5</span>)     <span class="co"># 单个 4x5 的矩阵</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="co"># B 的批量维度将被广播为 2</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> torch.matmul(A, B)  <span class="co"># 结果形状为 [2, 3, 5]</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C.shape)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 输出：torch.Size([2, 3, 5])</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>在这个示例中，<code>B</code> 的形状被视为 <code>[1, 4, 5]</code>，然后在第一个维度上广播为 <code>2</code>，以匹配 <code>A</code> 的批量维度。</p>
<ul>
<li><strong>示例 3：高维批量矩阵乘法</strong></li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 A，形状为 [D1, D2, M, K]</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> torch.randn(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 B，形状为 [D1, D2, K, N]</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> torch.randn(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 结果形状为 [2, 3, 4, 6]</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> torch.matmul(A, B)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C.shape)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 输出：torch.Size([2, 3, 4, 6])</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>在这里，<code>A</code> 和 <code>B</code> 都有批量维度 <code>[2, 3]</code>，<code>torch.matmul</code> 会在这两个维度上逐元素地执行矩阵乘法。</p>
<ul>
<li><strong>示例 4：批量维度的广播</strong></li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 A，形状为 [D1, M, K]</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> torch.randn(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 张量 B，形状为 [D2, K, N]</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> torch.randn(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>)  <span class="co"># 注意 D2=1，可以广播</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 批量维度将被广播为 [2]</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> torch.matmul(A, B)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C.shape)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 输出：torch.Size([2, 3, 5])</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p><strong>广播机制的详细解释</strong></p></li>
<li><p><strong>对齐维度：</strong></p>
<ul>
<li>假设 <code>A</code> 的维度是 <code>[A_1, A_2, ..., A_n, M, K]</code>，<code>B</code> 的维度是 <code>[B_1, B_2, ..., B_n, K, N]</code>。</li>
<li>其中，<code>A</code> 和 <code>B</code> 的批量维度是 <code>[A_1, A_2, ..., A_n]</code> 和 <code>[B_1, B_2, ..., B_n]</code>。</li>
</ul></li>
<li><p><strong>批量维度的广播：</strong></p>
<ul>
<li>对于每个批量维度 <code>i</code>，如果 <code>A_i == B_i</code>，或者其中一个为 <code>1</code>，则可以进行广播。</li>
<li>结果的批量维度为每个 <code>A_i</code> 和 <code>B_i</code> 中较大的那个。</li>
</ul></li>
<li><p><strong>矩阵乘法：</strong></p>
<ul>
<li>在广播后的批量维度上，<code>torch.matmul</code> 在 <code>A</code> 和 <code>B</code> 的最后两个维度上执行矩阵乘法。</li>
<li>即对于每个批量，执行形状</li>
</ul></li>
<li><p><strong>注意事项</strong></p></li>
</ul>
<ol type="1">
<li><strong>维度匹配：</strong>
<ul>
<li>确保用于矩阵乘法的最后两个维度是可乘的，即 <code>A</code> 的倒数第二个维度 <code>K</code> 与 <code>B</code> 的倒数第二个维度 <code>K</code> 相等。</li>
</ul></li>
<li><strong>广播限制：</strong>
<ul>
<li>如果批量维度不能广播（即尺寸不相等且没有为 <code>1</code> 的维度），会引发错误。</li>
</ul></li>
<li><strong>性能考虑：</strong>
<ul>
<li>高维矩阵乘法可能会占用大量内存和计算资源，处理大型数据时需要注意优化。</li>
</ul></li>
</ol>
<ul>
<li><p><strong>常见应用</strong></p></li>
<li><p><strong>神经网络中的批量处理：</strong></p>
<ul>
<li>在处理批量数据时，如批量输入样本，<code>torch.matmul</code> 可以高效地执行矩阵乘法。</li>
</ul></li>
<li><p><strong>注意力机制：</strong></p>
<ul>
<li>在实现自注意力（Self-Attention）时，需要对高维张量进行矩阵乘法。</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 示例：自注意力中的矩阵乘法</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>seq_len <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>d_model <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 输入张量，形状为 [batch_size, seq_len, d_model]</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>queries <span class="op">=</span> torch.randn(batch_size, seq_len, d_model)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>keys <span class="op">=</span> torch.randn(batch_size, seq_len, d_model)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 转置 keys 的最后两个维度</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>keys_transposed <span class="op">=</span> keys.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 矩阵乘法，结果形状为 [batch_size, seq_len, seq_len]</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>attention_scores <span class="op">=</span> torch.matmul(queries, keys_transposed)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(attention_scores.shape)</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 输出：torch.Size([8, 20, 20])</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>与 <code>torch.bmm</code> 的区别</strong></p></li>
<li><p><code>torch.bmm</code>（批量矩阵乘法）仅适用于维度为 3 的张量（形状为 <code>[batch_size, M, N]</code>），即只能处理单个批量维度。</p></li>
<li><p><code>torch.matmul</code> 更通用，可以处理维度 ≥ 1 的张量，支持多个批量维度。</p></li>
<li><p><strong>总结</strong></p></li>
<li><p><strong>高维矩阵乘法：</strong> <code>torch.matmul</code> 可以对高维张量进行批量矩阵乘法，批量维度按照广播机制处理。</p></li>
<li><p><strong>广播机制：</strong> 当批量维度不同时，PyTorch 会按照广播规则来扩展维度，以使得矩阵乘法可以进行。</p></li>
<li><p><strong>矩阵乘法维度：</strong> 确保用于矩阵乘法的两个张量的最后两个维度是可乘的（即形状为 <code>[M, K]</code> 和 <code>[K, N]</code>）。</p></li>
</ul>
<p>通过理解 <code>torch.matmul</code> 在高维时的行为和广播机制，您可以更有效地处理批量数据和高维矩阵运算。同时，注意调整张量的形状，以满足矩阵乘法的要求，可以避免在运行时出现错误。</p>
<ul>
<li><p><strong>参考文档</strong></p></li>
<li><p><a href="https://pytorch.org/docs/stable/generated/torch.matmul.html">PyTorch 官方文档：<code>torch.matmul</code></a></p></li>
<li><p><a href="https://pytorch.org/docs/stable/notes/broadcasting.html">PyTorch 广播语义</a></p></li>
</ul>
<p>希望以上解释能够帮助您理解 <code>torch.matmul</code> 在高维张量时的工作方式！</p></li>
<li><p>.squeeze 用法：<code>torch.squeeze(input, dim=None, out=None) -&gt; Tensor</code> 用来移除输入张量中的一维条目，即把所有维数为1的维度去掉。当给定dim时，那么只移除给定维数为1的维度。返回的张量会和输入张量共享内存，所以改变其中一个的内容会改变另一个。</p></li>
<li><p>.unsqueeze 用法：<code>torch.unsqueeze(input, dim, out=None) -&gt; Tensor</code> 返回一个新的张量，对输入的指定位置插入维度 1</p></li>
<li><p>.view 用法：<code>torch.view(*shape) -&gt; Tensor</code> ```python import torch</p>
<p># 创建一个张量 x = torch.randn(4, 4)</p>
<p># 使用 view 方法改变张量形状 y = x.view(2, 8)</p>
<p>print(y.shape) # 输出：torch.Size([2, 8]) ```</p>
<p><code>view</code> 方法用于改变张量的形状，但不改变其数据。返回一个新的张量，具有指定的形状。需要注意的是，<code>view</code> 只能用于连续的张量。如果张量在内存中不是连续的，可以先使用 <code>contiguous()</code> 方法使其连续。</p>
<p><strong>示例</strong>：</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建一个非连续张量</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.randn(<span class="dv">4</span>, <span class="dv">4</span>).transpose(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 使张量连续</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>x_contiguous <span class="op">=</span> x.contiguous()</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用 view 方法改变张量形状</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> x_contiguous.view(<span class="dv">2</span>, <span class="dv">8</span>)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(y.shape)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 输出：torch.Size([2, 8])</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Dataloader</p>
<ul>
<li><code>torch.utils.data.DataLoader</code> 是 PyTorch 中用于加载数据的工具，可以自动进行批量加载、打乱数据等操作。</li>
<li><font color="red">注意：Dataloader可以传入numpy数组，返回tensor.</font> e.g.</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> Dataset,DataLoader</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>totoal_data<span class="op">=</span><span class="dv">50</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>batch_size<span class="op">=</span><span class="dv">10</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>dim<span class="op">=</span><span class="dv">5</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>dataset<span class="op">=</span>np.random.rand(batch_size,dim)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> data <span class="kw">in</span> DataLoader(dataset,batch_size<span class="op">=</span>batch_size, shuffle<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"The type of data is :</span><span class="sc">{}</span><span class="st">, the size of data is </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(<span class="bu">type</span>(data),data.size()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p><strong>基本用法</strong></p>
<ul>
<li>创建 DataLoader 对象时，需要传入一个 <code>Dataset</code> 对象，用于提供数据。</li>
<li>可以指定 <code>batch_size</code> 参数，表示每个批次的样本数量。</li>
<li>可以设置 <code>shuffle=True</code>，表示在每个 epoch 开始时打乱数据。</li>
<li>可以设置 <code>num_workers</code>，表示用于数据加载的子进程数。</li>
</ul></li>
<li><p><strong>示例</strong> ```python import torch from torch.utils.data import DataLoader, TensorDataset</p>
<p># 创建一个张量数据集 data = torch.randn(100, 3) targets = torch.randint(0, 2, (100,))</p>
<p>dataset = TensorDataset(data, targets)</p>
<p># 创建 DataLoader 对象 dataloader = DataLoader(dataset, batch_size=4, shuffle=True)</p>
<p># 遍历 DataLoader for batch in dataloader: inputs, labels = batch print(inputs.shape, labels.shape) ```</p></li>
<li><p><strong>注意事项</strong></p>
<ul>
<li><strong>数据集</strong>：<code>DataLoader</code> 需要传入一个 <code>Dataset</code> 对象，如 <code>TensorDataset</code>、<code>ImageFolder</code> 等。</li>
<li><strong>批量大小</strong>：可以通过 <code>batch_size</code> 参数指定每个批次的样本数量。</li>
<li><strong>打乱数据</strong>：设置 <code>shuffle=True</code> 可以在每个 epoch 开始时打乱数据。</li>
<li><strong>多进程加载</strong>：可以设置 <code>num_workers</code> 参数，表示用于数据加载的子进程数。</li>
</ul></li>
</ul></li>
<li><p>torch.nn.CrossEntropyLoss</p>
<ul>
<li><p><strong><code>torch.nn.CrossEntropyLoss</code></strong> 是 PyTorch 中用于多分类任务的损失函数。它结合了 <code>nn.LogSoftmax()</code> 和 <code>nn.NLLLoss()</code>，适用于分类问题。</p></li>
<li><p><strong>基本用法</strong>：</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建损失函数对象</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>criterion <span class="op">=</span> nn.CrossEntropyLoss()</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设有两个样本的预测值和对应的标签</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>predictions <span class="op">=</span> torch.tensor([[<span class="fl">2.0</span>, <span class="fl">1.0</span>, <span class="fl">0.1</span>], [<span class="fl">0.5</span>, <span class="fl">2.5</span>, <span class="fl">0.3</span>]])</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> torch.tensor([<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算损失</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> criterion(predictions, labels)</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loss.item())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>初始化参数</strong>：</p>
<ul>
<li><code>weight</code>：可选，给每个类别的损失赋予不同的权重。</li>
<li><code>size_average</code>：已弃用，使用 <code>reduction</code> 参数代替。</li>
<li><code>ignore_index</code>：可选，指定一个类别索引，该类别的损失将被忽略。</li>
<li><code>reduction</code>：指定应用于输出的归约方式，默认为 <code>mean</code>。可选值为 <code>none</code>、<code>mean</code> 和 <code>sum</code>。</li>
</ul></li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>目标标签应该是类别的索引（整数），而不是独热编码（one-hot encoding）。</li>
<li>标签的形状应为 [batch_size]，每个元素是 [0, C-1] 之间的整数，其中 C 是类别数。</li>
<li>input（logits）的形状应为 [batch_size, num_classes]。对于多维输入（如时间序列），可能需要调整 input 和 target 的形状以匹配。</li>
<li>避免手动添加 Softmax 层：因为 CrossEntropyLoss 已经包含了 LogSoftmax，手动添加 Softmax 会导致计算上的重复和不必要的数值问题。</li>
</ul></li>
</ul></li>
<li><p>.permute和.reshape区别：</p>
<ul>
<li><p><strong><code>permute</code> 和 <code>reshape</code> 的区别</strong>：</p>
<ul>
<li><code>permute</code> 和 <code>reshape</code> 都可以用于改变张量的形状，但它们的作用有所不同。</li>
<li><code>permute</code> 用于交换张量的维度，可以灵活地调整维度的顺序。</li>
<li><code>reshape</code> 用于改变张量的形状，但不能改变张量的维度顺序。</li>
<li><code>permute</code> 通常用于高维张量的维度交换，<code>reshape</code> 用于形状调整。</li>
</ul></li>
<li><p><strong>示例</strong>： ```python import torch</p>
<p># 创建一个 3x4x5 的张量 x = torch.randn(3, 4, 5)</p>
<p># 使用 permute 交换维度 y = x.permute(1, 2, 0) # 将第 1 维移动到最后 print(y.shape) # 输出：torch.Size([4, 5, 3])</p>
<p># 使用 reshape 改变形状 z = x.reshape(2, 3, 10) # 改为 2x3x10 print(z.shape) # 输出：torch.Size([2, 3, 10]) ```</p></li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><code>permute</code> 和 <code>reshape</code> 都是返回新的张量，不会改变原始张量。</li>
<li><code>permute</code> 可以交换维度，但不能改变维度的数量。</li>
<li><code>reshape</code> 可以改变形状，但不能改变维度的顺序。</li>
<li>在处理高维张量时，<code>permute</code> 和 <code>reshape</code> 可以灵活地调整张量的形状和维度顺序。 ##### 其它模块</li>
</ul></li>
</ul></li>
<li><p>nn.sequential和nn.ModuleList: nn.ModuleList 是 PyTorch 中 torch.nn 模块的一部分，用于存储一组子模块。这些子模块通常是神经网络的层，nn.ModuleList 可以方便地管理它们，同时与 PyTorch 的其他功能（如自动微分和模型参数管理）集成良好。</p></li>
</ol>
<p><strong>特点和功能</strong> - <strong>存储子模块</strong>： nn.ModuleList 是一个有序的模块列表，每个元素都是 nn.Module 的实例（例如线性层、卷积层等）。 - <strong>动态构造网络</strong>： 可以在构造时动态地添加、删除或访问子模块，非常适合可变层数或结构的模型。 - <strong>参数管理</strong>： 使用 nn.ModuleList 添加的子模块，其参数会自动注册到父模块中，便于优化和保存。</p>
<p><strong>与 Python 的普通列表的区别</strong>： - 普通列表只是 Python 数据容器，无法与 PyTorch 的模块管理系统集成。 - nn.ModuleList 会确保其中的模块正确加入模型中，参与训练和推理。</p>
<p><strong>基本用法</strong> - <strong>定义和使用</strong>： ```python import torch import torch.nn as nn</p>
<pre><code>class MyModel(nn.Module):
    def __init__(self):
        super(MyModel, self).__init__()
        # 创建一个 ModuleList，包含多个线性层
        self.layers = nn.ModuleList([
            nn.Linear(10, 20),
            nn.Linear(20, 30),
            nn.Linear(30, 40)
        ])

    def forward(self, x):
        for layer in self.layers:
            x = layer(x)
        return x

# 实例化模型
model = MyModel()

# 输入张量
input_tensor = torch.randn(1, 10)

# 前向传播
output = model(input_tensor)
print(output.shape)  # 输出: torch.Size([1, 40])
```</code></pre>
<ul>
<li><p><strong>动态添加模块</strong>： ```python # 动态添加层 model.layers.append(nn.Linear(40, 50))</p>
<p># 更新后前向传播 output = model(input_tensor) print(output.shape) # 输出: torch.Size([1, 50]) ```</p></li>
</ul>
<p><strong>常见问题和注意事项</strong> - <strong>与 Sequential 的区别</strong>： - nn.ModuleList 只是存储模块，不会定义顺序的前向传播逻辑。 - 如果需要自动执行前向传播逻辑，可以使用 nn.Sequential。 <code>python     nn.Sequential(         nn.Linear(10, 20),         nn.ReLU(),         nn.Linear(20, 30)     )</code> - 而使用 nn.ModuleList 时，你需要手动定义 forward 函数来调用每一层。</p>
<ul>
<li><strong>不支持张量</strong>：
<ul>
<li>nn.ModuleList 只能存储 nn.Module 子类的实例，不能存储张量或普通 Python 对象。</li>
<li>如果需要存储张量，可以直接用 Python 列表。</li>
</ul></li>
<li><strong>访问方式</strong>： 可以像 Python 列表一样通过索引访问其中的模块。</li>
</ul>
<p><strong>使用场景</strong> - <strong>动态网络</strong>： 在网络结构中，层的数量可能不固定。例如，RNN、Transformer 等模型中，可能需要存储若干个重复的子模块。 - <strong>子网络管理</strong>： 当模型中需要管理多个不同的子模块时，nn.ModuleList 可以作为子模块的容器，方便地对其进行迭代和操作。</p>
</section>
</section>
<section id="scikit-learn-keras" class="level4">
<h4 class="anchored" data-anchor-id="scikit-learn-keras">scikit-learn (keras)</h4>
<ol type="1">
<li><code>precision_recall_curve</code>: 返回不同阈值下的 precision 和 recall 以及阈值</li>
<li><code>roc_auc_score</code></li>
<li><code>verbose</code>: 控制输出信息</li>
</ol>
</section>
<section id="tensorflow" class="level4">
<h4 class="anchored" data-anchor-id="tensorflow">tensorflow</h4>
<ol type="1">
<li><code>tf.compact</code></li>
<li><code>tf.zeros</code></li>
<li><code>tf.eye</code></li>
<li><code>tf.shape</code></li>
<li><code>tf.linalg</code>: 对角阵 <code>tf.eye</code> 是单位阵</li>
</ol>
</section>
<section id="快捷键" class="level4">
<h4 class="anchored" data-anchor-id="快捷键">快捷键</h4>
<ol type="1">
<li>多行注释：<code>Shift + P</code></li>
<li>多行前移：<code>Shift + Tab</code></li>
<li>反撤销：<code>Ctrl + Shift + Z</code></li>
<li>Fn 与功能键（声音等）冲突：<code>Fn + F12</code></li>
</ol>
</section>
<section id="terminal-命令" class="level4">
<h4 class="anchored" data-anchor-id="terminal-命令">terminal 命令</h4>
<ul>
<li><code>history | grep &lt;关键词&gt;</code></li>
<li>查看帮助：<code>info ls</code> 或 <code>ls --help</code></li>
<li><code>cat 文件</code>: 打开文件</li>
</ul>
</section>
<section id="git-命令" class="level4">
<h4 class="anchored" data-anchor-id="git-命令">git 命令</h4>
<ul>
<li><p><code>index</code>: 暂存区</p></li>
<li><p><code>working tree</code>: 工作区</p></li>
<li><p>vscode 下 git diff 视图：左边是历史，右边是当前的</p></li>
<li><p><code>git log</code>: <code>git log</code> 后一直没有光标问题解决：按 <code>q</code></p></li>
<li><p><code>git reflog</code>: 获得版本号</p></li>
<li><p><code>git status</code></p></li>
<li><p><code>git diff &lt;文件名&gt;</code></p></li>
<li><p><code>git add</code></p></li>
<li><p><code>git commit</code></p></li>
<li><p><code>git checkout --&lt;文件名&gt;</code>: 工作区回到和版本库相同状态（用于撤销修改，撤销删除）</p></li>
<li><p><code>git reset --hard HEAD^</code>: 版本回退 (HEAD 是指向 master 的指针)</p></li>
<li><p><code>git reset --hard &lt;版本号&gt;</code>: 到指定版本</p></li>
<li><p>追加到上一次提交：（待补充）</p></li>
<li><p>查看分支：<code>git branch</code></p></li>
<li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li>
<li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li>
<li><p>创建并切换分支：<code>git checkout -b &lt;name&gt;</code></p></li>
<li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p></li>
<li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li>
<li><p><code>git clone</code> 不会把 origin 的分支拉下来</p></li>
<li><p><code>git remote -v</code></p></li>
</ul>
<p>问题：git 比对版本的时候会不会丢失之前工作？</p>
</section>
<section id="some-technique" class="level4">
<h4 class="anchored" data-anchor-id="some-technique">Some technique</h4>
<ol type="1">
<li><code>non_zero_mask = a &gt; 0</code>: 获得为正的 index</li>
<li><code>perf = -1</code>: 有些函数会返回 -1</li>
</ol>
</section>
</section>
<section id="linux" class="level3">
<h3 class="anchored" data-anchor-id="linux">Linux:</h3>
<ol type="1">
<li>/opt和/usr区别： /usr中文件可以直接在命令行运行</li>
<li>桌面图标的位置： <code>/usr/share/applications/</code></li>
<li><code>/bin</code>和<code>/usr/bin</code>和<code>/usr/local/bin</code>的区别：</li>
</ol>
<ul>
<li><code>/bin</code>：系统命令，通常是系统自带的命令，如 <code>ls</code>, <code>cp</code>, <code>mv</code> 等。</li>
<li><code>/usr/bin</code>：用户命令，通常是系统自带的命令，如 <code>ls</code>, <code>cp</code>, <code>mv</code> 等。</li>
<li><code>/usr/local/bin</code>：用户命令，通常是用户安装的命令，如 <code>conda</code>, <code>pip</code> 等。</li>
</ul>
</section>
<section id="mysql" class="level3">
<h3 class="anchored" data-anchor-id="mysql">Mysql</h3>
<ol type="1">
<li>几个英文句子的含义：</li>
</ol>
<ul>
<li>“connecting to MySQL using a blank password”：使用空密码连接到 MySQL</li>
<li>“VALIDATE PASSWORD COMPONENT can be used to test passwords”：使用密码验证组件来测试密码</li>
<li></li>
</ul>
</section>
<section id="cuda安装" class="level3">
<h3 class="anchored" data-anchor-id="cuda安装">CUDA安装：</h3>
<ol type="1">
<li><code>nvidia-smi</code> 查看显卡信息; cuda version是支持的最高版本</li>
</ol>
</section>
<section id="cursor" class="level3">
<h3 class="anchored" data-anchor-id="cursor">Cursor：</h3>
<p>Compresser 引用</p>
</section>
<section id="vscodecursor-设置" class="level3">
<h3 class="anchored" data-anchor-id="vscodecursor-设置">VScode/Cursor 设置：</h3>
<ol type="1">
<li><strong>设置快捷键</strong>：
<ul>
<li><code>Ctrl + K Ctrl + S</code></li>
<li>打开 <code>keybinds.json</code> 文件：</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"key"</span><span class="fu">:</span> <span class="st">"ctrl+1"</span><span class="fu">,</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"command"</span><span class="fu">:</span> <span class="st">"editor.action.insertSnippet"</span><span class="fu">,</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"args"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">"snippet"</span><span class="fu">:</span> <span class="st">"(需要插入代码)"</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">},</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">"when"</span><span class="fu">:</span> <span class="st">"editorTextFocus"</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>command</code> 除了以上还有 <code>type</code> 选项，用于直接插入指定的文本，不支持设置光标位置</li>
</ul></li>
<li><strong>Markdown 在插入行间公式后不显示的问题</strong>：
<ul>
<li>参考链接: <a href="https://github.com/yzhang-gh/vscode-markdown/issues/1032">GitHub Issue #1032</a></li>
<li>解决方案：禁用 <code>markdown-math</code> 扩展，使用 <code>@builtin markdown</code> 禁用。</li>
</ul></li>
<li>enable editor preview单击打开文件后无法出现在bar中。</li>
<li>activate bar是最左侧一栏 ### 网络相关：</li>
<li><code>netstat -ano</code> 是一个 Windows 命令，用于显示网络连接、路由表、网络接口统计信息以及网络协议的详细信息。以下是该命令的输出解释：</li>
</ol>
<ul>
<li><code>-a</code>：显示所有连接和监听端口。</li>
<li><code>-n</code>：以数字形式显示地址和端口号。</li>
<li><code>-o</code>：显示与每个连接关联的进程 ID (PID)。</li>
</ul>
<p>你可以在命令提示符中运行以下命令来查看网络连接：</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">netstat</span> <span class="at">-ano</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>这将输出类似以下内容：</p>
<pre><code>Proto  Local Address          Foreign Address        State           PID
TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       1234
TCP    192.168.1.100:139      192.168.1.101:445      ESTABLISHED     5678
...</code></pre>
<ul>
<li><code>Proto</code>：协议类型（TCP 或 UDP）。</li>
<li><code>Local Address</code>：本地地址和端口号。</li>
<li><code>Foreign Address</code>：远程地址和端口号。</li>
<li><code>State</code>：连接状态（如 LISTENING、ESTABLISHED 等）。</li>
<li><code>PID</code>：进程 ID，可以在任务管理器中找到对应的进程。</li>
</ul>
<p>如果你需要进一步分析某个特定的连接，可以使用 <code>tasklist</code> 命令结合 PID 来找到对应的进程：</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ex">tasklist</span> /FI <span class="st">"PID eq 1234"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>这将显示 PID 为 1234 的进程信息。</p>
<ol start="2" type="1">
<li>HTTP与HTTPS区别 HTTP（HyperText Transfer Protocol）和 HTTPS（HyperText Transfer Protocol Secure）是用于在 Web 浏览器和 Web 服务器之间传输数据的协议。以下是它们的主要区别：
<ol type="1">
<li><strong>安全性</strong>：</li>
</ol>
<ul>
<li><strong>HTTP</strong>：数据以明文形式传输，容易被中间人攻击（如窃听、篡改）。</li>
<li><strong>HTTPS</strong>：使用 SSL/TLS 协议对数据进行加密，确保数据在传输过程中不被窃听和篡改。</li>
</ul>
<ol start="2" type="1">
<li><strong>端口</strong>：</li>
</ol>
<ul>
<li><strong>HTTP</strong>：默认使用端口 80。</li>
<li><strong>HTTPS</strong>：默认使用端口 443。</li>
</ul>
<ol start="3" type="1">
<li><strong>证书</strong>：</li>
</ol>
<ul>
<li><strong>HTTP</strong>：不需要证书。</li>
<li><strong>HTTPS</strong>：需要由受信任的证书颁发机构（CA）颁发的 SSL/TLS 证书。</li>
</ul>
<ol start="4" type="1">
<li><strong>性能</strong>：</li>
</ol>
<ul>
<li><strong>HTTP</strong>：由于没有加密和解密过程，性能稍微高一些。</li>
<li><strong>HTTPS</strong>：由于需要加密和解密数据，性能稍微低一些，但现代硬件和优化技术已经使得这种差异非常小。</li>
</ul>
<ol start="5" type="1">
<li><strong>SEO</strong>：</li>
</ol>
<ul>
<li><strong>HTTP</strong>：搜索引擎对 HTTP 网站的排名可能较低。</li>
<li><strong>HTTPS</strong>：搜索引擎（如 Google）更倾向于对 HTTPS 网站进行更高的排名。</li>
</ul>
<ol start="6" type="1">
<li><strong>浏览器支持</strong>：</li>
</ol>
<ul>
<li><strong>HTTP</strong>：现代浏览器会标记 HTTP 网站为“不安全”。</li>
<li><strong>HTTPS</strong>：现代浏览器会显示安全锁图标，表示网站是安全的。</li>
</ul>
总结：
<ul>
<li><strong>HTTP</strong> 适用于不需要保护敏感数据的普通网站。</li>
<li><strong>HTTPS</strong> 适用于需要保护敏感数据（如登录信息、支付信息）的安全网站。</li>
</ul></li>
</ol>
</section>
<section id="common-knowledge" class="level3">
<h3 class="anchored" data-anchor-id="common-knowledge">common knowledge</h3>
<section id="init__.py-作用" class="level5">
<h5 class="anchored" data-anchor-id="init__.py-作用"><code>__init__.py</code> 作用：</h5>
<ol type="1">
<li>使得文件夹成为一个 package</li>
<li>定义包的初始化行为：<code>__init__.py</code> 文件可以包含代码，在导入包时自动执行。你可以在其中初始化包的状态或导入其他模块</li>
<li>控制包的导出内容：可以使用 <code>__init__.py</code> 中的 <code>__all__</code> 列表来定义当使用 <code>from package import *</code> 时导出的模块或函数</li>
<li>简化导入路径：你可以在 <code>__init__.py</code> 中导入包内的模块，使外部使用时路径更加简洁</li>
</ol>
</section>
<section id="文档里方括号含义" class="level5">
<h5 class="anchored" data-anchor-id="文档里方括号含义">文档里方括号含义：</h5>
<p>方括号 <code>[]</code> 通常表示可选参数。这意味着在调用函数时，可以选择性地提供这些参数；如果不提供，则使用默认值。 例如：<code>dict.get(key[, default])</code></p>
</section>
<section id="给函数编写文档" class="level5">
<h5 class="anchored" data-anchor-id="给函数编写文档">给函数编写文档</h5>
<p>在 Python 的文档字符串（docstring）中，<code>:param</code> 和 <code>Args:</code> 都用于描述函数参数，但它们的使用方式和风格有所不同。以下是它们的区别和示例：</p>
<ol type="1">
<li><code>:param</code> 标记 <code>:param</code> 标记是一种详细的参数描述方式，通常与 <code>:type</code> 标记一起使用。它们的格式如下：</li>
</ol>
<div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>:param param_name: 描述参数的用途</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>:<span class="bu">type</span> param_name: 参数的类型</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><code>Args:</code> 标记 <code>Args:</code> 标记是一种简洁的参数描述方式，通常用于 Google 风格的文档字符串。它的格式如下：</li>
</ol>
<div class="sourceCode" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>Args:</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    param_name (param_type): 描述参数的用途</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li>示例对比</li>
</ol>
<p>使用 <code>:param</code> 标记：</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train(epochs<span class="op">=</span><span class="dv">20</span>, batchSize<span class="op">=</span><span class="dv">1024</span>, lr<span class="op">=</span><span class="fl">0.01</span>, lamda<span class="op">=</span><span class="fl">0.1</span>, factors_dim<span class="op">=</span><span class="dv">64</span>):</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co">    训练ALS模型。</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="co">    该函数使用交替最小二乘法（ALS）训练推荐系统模型。模型通过多次迭代和批量梯度下降来优化用户和物品的隐向量。</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="co">    :param epochs: 迭代次数，默认为20。</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="co">    :type epochs: int</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="co">    :param batchSize: 每个批次的数据量，默认为1024。</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="co">    :type batchSize: int</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a><span class="co">    :param lr: 学习率，默认为0.01。</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="co">    :type lr: float</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="co">    :param lamda: 正则化系数，默认为0.1。</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="co">    :type lamda: float</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="co">    :param factors_dim: 隐因子的数量，默认为64。</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="co">    :type factors_dim: int</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="co">    :return: None</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 函数实现</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>使用 <code>Args:</code> 标记：</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train(epochs<span class="op">=</span><span class="dv">20</span>, batchSize<span class="op">=</span><span class="dv">1024</span>, lr<span class="op">=</span><span class="fl">0.01</span>, lamda<span class="op">=</span><span class="fl">0.1</span>, factors_dim<span class="op">=</span><span class="dv">64</span>):</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co">    训练ALS模型。</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co">    该函数使用交替最小二乘法（ALS）训练推荐系统模型。模型通过多次迭代和批量梯度下降来优化用户和物品的隐向量。</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="co">        epochs (int): 迭代次数，默认为20。</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="co">        batchSize (int): 每个批次的数据量，默认为1024。</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="co">        lr (float): 学习率，默认为0.01。</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a><span class="co">        lamda (float): 正则化系数，默认为0.1。</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="co">        factors_dim (int): 隐因子的数量，默认为64。</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a><span class="co">        None</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 函数实现</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="4" type="1">
<li>选择哪种风格</li>
</ol>
<ul>
<li><strong><code>:param</code> 标记</strong>：适用于 Sphinx 风格的文档字符串，通常与 <code>:type</code> 标记一起使用，提供详细的参数描述。</li>
<li><strong><code>Args:</code> 标记</strong>：适用于 Google 风格的文档字符串，简洁明了，适合快速描述参数。</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>